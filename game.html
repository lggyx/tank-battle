<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>坦克大战 - 战场</title>
  <style>
    html, body { height: 100%; }
    body {
      margin: 0;
      background: url('assets/images/index.jpg') no-repeat center center fixed;
      background-size: cover;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
    }
    .hud {
      position: fixed; left: 16px; top: 16px; right: 16px;
      display: flex; align-items: center; justify-content: space-between;
      background: rgba(0,0,0,0.55);
      border: 1px solid #ffd700; border-radius: 10px; padding: 10px 12px;
      box-shadow: 0 0 12px rgba(255,215,0,0.35);
    }
    .hud .stat { font-weight: 700; }
    .container { display: grid; place-items: center; height: 100%; }
    .canvas-wrap { border: 2px solid #ffd700; border-radius: 10px; background: rgba(0,0,0,0.45); }
    canvas { image-rendering: pixelated; display: block; }
    .btn {
      appearance: none; border: 1px solid #ffd700; border-radius: 8px; padding: 8px 12px;
      background: rgba(0,0,0,0.5); color: #fff; margin-left: 8px; cursor: pointer; font-weight: 700;
    }
  </style>
</head>
<body>
  <div class="hud">
    <div>
      <span class="stat">关卡：<span id="level">1</span></span>
      <span class="stat" style="margin-left:18px">生命：<span id="lives">3</span></span>
      <span class="stat" style="margin-left:18px">敌军：<span id="enemies">10</span></span>
    </div>
    <div>
      <button class="btn" id="pauseBtn">暂停(P)</button>
      <a class="btn" href="index.html">返回首页</a>
    </div>
  </div>

  <div class="container">
    <div class="canvas-wrap">
      <canvas id="game" width="512" height="448" aria-label="游戏画面"></canvas>
    </div>
  </div>

  <audio id="sndMove" src="assets/audio/move.mp3" preload="auto"></audio>
  <audio id="sndBullet" src="assets/audio/bulletCrack.mp3" preload="auto"></audio>
  <audio id="sndExplode" src="assets/audio/playerCrack.mp3" preload="auto"></audio>

  <script>
  (function(){
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const levelEl = document.getElementById('level');
    const livesEl = document.getElementById('lives');
    const enemiesEl = document.getElementById('enemies');
    const pauseBtn = document.getElementById('pauseBtn');

    const sndMove = document.getElementById('sndMove');
    const sndBullet = document.getElementById('sndBullet');
    const sndExplode = document.getElementById('sndExplode');

    let soundOn = true;
    function play(audio){ if(!soundOn) return; const p = audio.play(); if(p && p.catch) p.catch(()=>{}); }

    // Basic playable tank mechanics (classic-inspired)
    const tile = 32;
    const mapCols = Math.floor(canvas.width / tile);
    const mapRows = Math.floor(canvas.height / tile);
    const walls = new Set();
    const base = { x: mapCols-2, y: mapRows-2, w: 2, h: 2 };

    // Random walls for demo
    for(let i=2;i<mapCols-3;i++){
      if(i % 3 === 0) { walls.add(`${i}|6`); walls.add(`${i}|7`); }
    }

    const tankImg = new Image(); tankImg.src = 'assets/images/tankAll.gif';
    const player = { x: 2*tile, y: 2*tile, dir: 'up', speed: 2, size: 28 };
    const bullets = [];
    let paused = false;

    // difficulty from query string
    const params = new URLSearchParams(window.location.search);
    const diff = (params.get('difficulty') || 'normal').toLowerCase();
    const config = {
      easy:   { lives: 4, enemies: 6, wallDensity: 0.25, enemySpeed: 1.4, playerSpeed: 2.2 },
      normal: { lives: 3, enemies: 10, wallDensity: 0.35, enemySpeed: 1.6, playerSpeed: 2.0 },
      hard:   { lives: 2, enemies: 14, wallDensity: 0.45, enemySpeed: 1.9, playerSpeed: 1.8 },
    }[diff] || { lives: 3, enemies: 10, wallDensity: 0.35, enemySpeed: 1.6, playerSpeed: 2.0 };

    livesEl.textContent = String(config.lives);
    enemiesEl.textContent = String(config.enemies);
    player.speed = config.playerSpeed;

    // add some more walls based on density
    for(let x=1; x<mapCols-1; x++){
      for(let y=1; y<mapRows-3; y++){
        if((x+y) % 5 === 0 && Math.random() < config.wallDensity){
          const k = `${x}|${y}`;
          if(!walls.has(k) && !(x>=base.x && x<base.x+base.w && y>=base.y && y<base.y+base.h)){
            walls.add(k);
          }
        }
      }
    }

    // enemies patrol
    const enemies = [];
    function isBlocked(gx, gy){
      return walls.has(`${gx}|${gy}`) || (gx>=base.x && gx<base.x+base.w && gy>=base.y && gy<base.y+base.h);
    }
    function spawnEnemies(n){
      let tries = 0;
      while(enemies.length < n && tries < n*50){
        tries++;
        const gx = Math.floor(Math.random()*(mapCols-4))+2;
        const gy = Math.floor(Math.random()*(mapRows-6))+2;
        if(isBlocked(gx,gy)) continue;
        // avoid player start zone
        if(Math.abs(gx - Math.floor(player.x/tile)) + Math.abs(gy - Math.floor(player.y/tile)) < 6) continue;
        enemies.push({ x: gx*tile + tile/2, y: gy*tile + tile/2, dir: 'left', speed: config.enemySpeed, w: 26, h: 26, dead: false });
      }
    }
    spawnEnemies(config.enemies);

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // background grid
      ctx.globalAlpha = 0.25; ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.globalAlpha = 1;
      ctx.strokeStyle = 'rgba(255,215,0,0.25)';
      for(let x=0;x<=canvas.width;x+=tile){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
      for(let y=0;y<=canvas.height;y+=tile){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }

      // walls
      ctx.fillStyle = 'rgba(160,82,45,0.85)';
      walls.forEach(key=>{ const [cx,cy] = key.split('|').map(Number); ctx.fillRect(cx*tile,cy*tile,tile,tile); });

      // base
      ctx.fillStyle = 'rgba(255,0,0,0.7)';
      ctx.fillRect(base.x*tile, base.y*tile, base.w*tile, base.h*tile);
      ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2; ctx.strokeRect(base.x*tile, base.y*tile, base.w*tile, base.h*tile);
      ctx.fillStyle = '#ffd700'; ctx.font = 'bold 14px monospace'; ctx.fillText('基地', base.x*tile+8, base.y*tile+tile+6);

      // player tank
      ctx.drawImage(tankImg, 0,0,64,64, player.x-32+tile/2, player.y-32+tile/2, 64,64);

      // enemies
      ctx.fillStyle = '#00ff00';
      enemies.forEach(e=>{ if(!e.dead) ctx.fillRect(e.x-e.w/2, e.y-e.h/2, e.w, e.h); });

      // bullets
      ctx.fillStyle = '#ffd700';
      bullets.forEach(b=>{ ctx.fillRect(b.x-2,b.y-2,4,4); });
    }

    function collides(nx, ny){
      const gx = Math.floor(nx / tile), gy = Math.floor(ny / tile);
      return walls.has(`${gx}|${gy}`) || (gx>=base.x && gx<base.x+base.w && gy>=base.y && gy<base.y+base.h);
    }

    const keys = new Set();
    document.addEventListener('keydown', (e)=>{
      keys.add(e.key);
      if(e.code==='Space'){ shoot(); play(sndBullet); }
      if(e.key.toLowerCase()==='p'){ paused = !paused; }
    });
    document.addEventListener('keyup', (e)=> keys.delete(e.key));

    function update(){
      if(paused){ draw(); return; }
      let nx = player.x, ny = player.y;
      if(keys.has('w') || keys.has('ArrowUp')){ ny -= player.speed; player.dir='up'; play(sndMove); }
      if(keys.has('s') || keys.has('ArrowDown')){ ny += player.speed; player.dir='down'; play(sndMove); }
      if(keys.has('a') || keys.has('ArrowLeft')){ nx -= player.speed; player.dir='left'; play(sndMove); }
      if(keys.has('d') || keys.has('ArrowRight')){ nx += player.speed; player.dir='right'; play(sndMove); }
      if(!collides(nx, ny)){ player.x = nx; player.y = ny; }

      // enemies movement (patrol)
      enemies.forEach(e=>{
        if(e.dead) return;
        let ex=e.x, ey=e.y;
        if(e.dir==='left') ex -= e.speed; else if(e.dir==='right') ex += e.speed; else if(e.dir==='up') ey -= e.speed; else ey += e.speed;
        const gx = Math.floor(ex/tile), gy = Math.floor(ey/tile);
        if(isBlocked(gx,gy)){
          // change dir clockwise
          e.dir = e.dir==='left'?'up':e.dir==='up'?'right':e.dir==='right'?'down':'left';
        } else { e.x=ex; e.y=ey; }
      });

      bullets.forEach(b=>{
        if(b.dir==='up') b.y -= 4; else if(b.dir==='down') b.y += 4; else if(b.dir==='left') b.x -= 4; else b.x += 4;
        // hit wall
        const gx = Math.floor(b.x/tile), gy = Math.floor(b.y/tile);
        const k = `${gx}|${gy}`;
        if(walls.has(k)){ walls.delete(k); b.dead = true; play(sndExplode); }
        // out of bounds
        if(b.x<0||b.y<0||b.x>canvas.width||b.y>canvas.height){ b.dead = true; }
        // hit base
        if(gx>=base.x && gx<base.x+base.w && gy>=base.y && gy<base.y+base.h){ b.dead=true; livesEl.textContent = Math.max(0, Number(livesEl.textContent)-1); play(sndExplode); }
        // hit enemy
        enemies.forEach(e=>{
          if(e.dead) return;
          if(Math.abs(e.x - b.x) < e.w/2 && Math.abs(e.y - b.y) < e.h/2){ e.dead = true; b.dead = true; play(sndExplode); }
        });
      });
      for(let i=bullets.length-1;i>=0;i--){ if(bullets[i].dead) bullets.splice(i,1); }

      // enemy contact with player
      enemies.forEach(e=>{
        if(e.dead) return;
        if(Math.abs(e.x - player.x) < 20 && Math.abs(e.y - player.y) < 20){
          play(sndExplode);
          livesEl.textContent = Math.max(0, Number(livesEl.textContent)-1);
        }
      });

      draw();
      requestAnimationFrame(update);
    }

    function shoot(){ bullets.push({ x: player.x, y: player.y, dir: player.dir }); }

    pauseBtn.addEventListener('click', ()=>{ paused = !paused; });

    tankImg.onload = ()=>{ draw(); requestAnimationFrame(update); };
  })();
  </script>
</body>
</html>
