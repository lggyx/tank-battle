<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>坦克大战 - 战场</title>
  <style>
    html, body { height: 100%; }
    body {
      margin: 0;
      background: url('assets/images/index.jpg') no-repeat center center fixed;
      background-size: cover;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
    }
    .hud {
      position: fixed; left: 16px; top: 16px; right: 16px;
      display: flex; align-items: center; justify-content: space-between;
      background: rgba(0,0,0,0.55);
      border: 1px solid #ffd700; border-radius: 10px; padding: 10px 12px;
      box-shadow: 0 0 12px rgba(255,215,0,0.35);
    }
    .hud .stat { font-weight: 700; }
    .container { display: grid; place-items: center; height: 100%; }
    .canvas-wrap { border: 2px solid #ffd700; border-radius: 10px; background: rgba(0,0,0,0.45); }
    canvas { image-rendering: pixelated; display: block; }
    .btn {
      appearance: none; border: 1px solid #ffd700; border-radius: 8px; padding: 8px 12px;
      background: rgba(0,0,0,0.5); color: #fff; margin-left: 8px; cursor: pointer; font-weight: 700;
    }
  </style>
</head>
<body>
  <div class="hud">
    <div>
      <span class="stat">关卡：<span id="level">1</span></span>
      <span class="stat" style="margin-left:18px">生命：<span id="lives">3</span></span>
      <span class="stat" style="margin-left:18px">敌军：<span id="enemies">10</span></span>
    </div>
    <div>
      <button class="btn" id="pauseBtn">暂停(P)</button>
      <a class="btn" href="index.html">返回首页</a>
    </div>
  </div>

  <div class="container">
    <div class="canvas-wrap">
      <canvas id="game" width="512" height="448" aria-label="游戏画面"></canvas>
    </div>
  </div>

  <audio id="sndMove" src="assets/audio/move.mp3" preload="auto"></audio>
  <audio id="sndBullet" src="assets/audio/bulletCrack.mp3" preload="auto"></audio>
  <audio id="sndExplode" src="assets/audio/playerCrack.mp3" preload="auto"></audio>

  <script>
  (function(){
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const levelEl = document.getElementById('level');
    const livesEl = document.getElementById('lives');
    const enemiesEl = document.getElementById('enemies');
    const pauseBtn = document.getElementById('pauseBtn');

    const sndMove = document.getElementById('sndMove');
    const sndBullet = document.getElementById('sndBullet');
    const sndExplode = document.getElementById('sndExplode');

    let soundOn = true;
    function play(audio){ if(!soundOn) return; const p = audio.play(); if(p && p.catch) p.catch(()=>{}); }

    // Basic playable tank mechanics (classic-inspired)
    const tile = 32;
    const mapCols = Math.floor(canvas.width / tile);
    const mapRows = Math.floor(canvas.height / tile);
    // separate wall sets: bricks (destructible) and steel (indestructible)
    const brickWalls = new Set();
    const steelWalls = new Set();
    const base = { x: mapCols-2, y: mapRows-2, w: 2, h: 2 };

    // Level 1 layout: border steel, L-shaped corridor, base steel protection
    // border steel frame
    for(let x=0;x<mapCols;x++){ steelWalls.add(`${x}|0`); steelWalls.add(`${x}|${mapRows-1}`); }
    for(let y=0;y<mapRows;y++){ steelWalls.add(`0|${y}`); steelWalls.add(`${mapCols-1}|${y}`); }
    // fill bricks except corridors and base zone
    for(let x=1;x<mapCols-1;x++){
      for(let y=1;y<mapRows-1;y++){
        const inBase = (x>=base.x-1 && x<=base.x+base.w && y>=base.y-1 && y<=base.y+base.h);
        // L corridor: top row path to right, then down, then left at bottom per diagram
        const isCorridor = (y===2 && x>=2 && x<=mapCols-3) || (x===mapCols-3 && y>=3 && y<=mapRows-4) || (y===mapRows-4 && x>=2 && x<=mapCols-4);
        if(!isCorridor && !inBase){ brickWalls.add(`${x}|${y}`); }
      }
    }
    // steel protect base fully (ring around base)
    for(let x=base.x-1;x<=base.x+base.w;x++){
      for(let y=base.y-1;y<=base.y+base.h;y++){
        if(!(x>=base.x && x<base.x+base.w && y>=base.y && y<base.y+base.h)){
          steelWalls.add(`${x}|${y}`);
        }
      }
    }

    const tankImg = new Image(); tankImg.src = 'assets/images/tankAll.gif';
    const player = { x: 2*tile, y: 2*tile, dir: 'up', speed: 2, size: 28 };
    const bullets = [];
    const enemyBullets = [];
    let paused = false;

    // difficulty from query string
    const params = new URLSearchParams(window.location.search);
    const diff = (params.get('difficulty') || 'normal').toLowerCase();
    const config = {
      easy:   { lives: 4, enemies: 6, wallDensity: 0.25, enemySpeed: 1.4, playerSpeed: 2.2 },
      normal: { lives: 3, enemies: 10, wallDensity: 0.35, enemySpeed: 1.6, playerSpeed: 2.0 },
      hard:   { lives: 2, enemies: 14, wallDensity: 0.45, enemySpeed: 1.9, playerSpeed: 1.8 },
    }[diff] || { lives: 3, enemies: 10, wallDensity: 0.35, enemySpeed: 1.6, playerSpeed: 2.0 };

    livesEl.textContent = String(config.lives);
    enemiesEl.textContent = String(config.enemies);
    player.speed = config.playerSpeed;

    // add some more brick walls based on density (destructible), avoid base zone and existing walls
    for(let x=1; x<mapCols-1; x++){
      for(let y=1; y<mapRows-3; y++){
        if((x+y) % 5 === 0 && Math.random() < config.wallDensity){
          const k = `${x}|${y}`;
          const inBaseZone = (x>=base.x && x<base.x+base.w && y>=base.y && y<base.y+base.h);
          if(!inBaseZone && !brickWalls.has(k) && !steelWalls.has(k)){
            brickWalls.add(k);
          }
        }
      }
    }

    // enemies patrol
    const enemies = [];
    function isBlocked(gx, gy){
      return brickWalls.has(`${gx}|${gy}`) || steelWalls.has(`${gx}|${gy}`) || (gx>=base.x && gx<base.x+base.w && gy>=base.y && gy<base.y+base.h);
    }
    function spawnEnemies(n){
      let tries = 0;
      while(enemies.length < n && tries < n*50){
        tries++;
        const gx = Math.floor(Math.random()*(mapCols-4))+2;
        const gy = Math.floor(Math.random()*(mapRows-6))+2;
        if(isBlocked(gx,gy)) continue;
        // avoid player start zone
        if(Math.abs(gx - Math.floor(player.x/tile)) + Math.abs(gy - Math.floor(player.y/tile)) < 6) continue;
        enemies.push({ x: gx*tile + tile/2, y: gy*tile + tile/2, dir: 'left', speed: config.enemySpeed, w: 26, h: 26, dead: false });
      }
    }
    spawnEnemies(config.enemies);

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // background grid
      ctx.globalAlpha = 0.25; ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.globalAlpha = 1;
      ctx.strokeStyle = 'rgba(255,215,0,0.25)';
      for(let x=0;x<=canvas.width;x+=tile){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
      for(let y=0;y<=canvas.height;y+=tile){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }

      // walls: bricks and steel
      ctx.fillStyle = 'rgba(160,82,45,0.85)';
      brickWalls.forEach(key=>{ const [cx,cy] = key.split('|').map(Number); ctx.fillRect(cx*tile,cy*tile,tile,tile); });
      ctx.fillStyle = 'rgba(192,192,192,0.95)';
      steelWalls.forEach(key=>{ const [cx,cy] = key.split('|').map(Number); ctx.fillRect(cx*tile,cy*tile,tile,tile); });

      // base
      ctx.fillStyle = 'rgba(255,0,0,0.7)';
      ctx.fillRect(base.x*tile, base.y*tile, base.w*tile, base.h*tile);
      ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2; ctx.strokeRect(base.x*tile, base.y*tile, base.w*tile, base.h*tile);
      ctx.fillStyle = '#ffd700'; ctx.font = 'bold 14px monospace'; ctx.fillText('基地', base.x*tile+8, base.y*tile+tile+6);

      // player tank
      ctx.drawImage(tankImg, 0,0,64,64, player.x-32+tile/2, player.y-32+tile/2, 64,64);

      // enemies
      ctx.fillStyle = '#00ff00';
      enemies.forEach(e=>{ if(!e.dead) ctx.fillRect(e.x-e.w/2, e.y-e.h/2, e.w, e.h); });

      // bullets (player)
      ctx.fillStyle = '#ffd700';
      bullets.forEach(b=>{ ctx.fillRect(b.x-2,b.y-2,4,4); });
      // bullets (enemy)
      ctx.fillStyle = '#ff4500';
      enemyBullets.forEach(b=>{ ctx.fillRect(b.x-2,b.y-2,4,4); });
    }

    function collides(nx, ny){
      const gx = Math.floor(nx / tile), gy = Math.floor(ny / tile);
      return brickWalls.has(`${gx}|${gy}`) || steelWalls.has(`${gx}|${gy}`) || (gx>=base.x && gx<base.x+base.w && gy>=base.y && gy<base.y+base.h);
    }

    const keys = new Set();
    document.addEventListener('keydown', (e)=>{
      keys.add(e.key);
      if(e.code==='Space'){ shoot(); play(sndBullet); }
      if(e.key.toLowerCase()==='p'){ paused = !paused; }
    });
    document.addEventListener('keyup', (e)=> keys.delete(e.key));

    function update(){
      if(paused){ draw(); return; }
      let nx = player.x, ny = player.y;
      if(keys.has('w') || keys.has('ArrowUp')){ ny -= player.speed; player.dir='up'; play(sndMove); }
      if(keys.has('s') || keys.has('ArrowDown')){ ny += player.speed; player.dir='down'; play(sndMove); }
      if(keys.has('a') || keys.has('ArrowLeft')){ nx -= player.speed; player.dir='left'; play(sndMove); }
      if(keys.has('d') || keys.has('ArrowRight')){ nx += player.speed; player.dir='right'; play(sndMove); }
      if(!collides(nx, ny)){ player.x = nx; player.y = ny; }

      // enemies movement (patrol)
      enemies.forEach(e=>{
        if(e.dead) return;
        let ex=e.x, ey=e.y;
        if(e.dir==='left') ex -= e.speed; else if(e.dir==='right') ex += e.speed; else if(e.dir==='up') ey -= e.speed; else ey += e.speed;
        const gx = Math.floor(ex/tile), gy = Math.floor(ey/tile);
        if(isBlocked(gx,gy)){
          // change dir clockwise
          e.dir = e.dir==='left'?'up':e.dir==='up'?'right':e.dir==='right'?'down':'left';
        } else { e.x=ex; e.y=ey; }
        // enemy shoot occasionally (关卡1敌弹速度降低50%)
        if(Math.random() < 0.01){ enemyBullets.push({ x: e.x, y: e.y, dir: e.dir }); }
      });

      bullets.forEach(b=>{
        if(b.dir==='up') b.y -= 4; else if(b.dir==='down') b.y += 4; else if(b.dir==='left') b.x -= 4; else b.x += 4;
        // hit wall
        const gx = Math.floor(b.x/tile), gy = Math.floor(b.y/tile);
        const k = `${gx}|${gy}`;
        if(brickWalls.has(k)){ brickWalls.delete(k); b.dead = true; play(sndExplode); }
        if(steelWalls.has(k)){ b.dead = true; }
        // out of bounds
        if(b.x<0||b.y<0||b.x>canvas.width||b.y>canvas.height){ b.dead = true; }
        // hit base
        if(gx>=base.x && gx<base.x+base.w && gy>=base.y && gy<base.y+base.h){ b.dead=true; livesEl.textContent = Math.max(0, Number(livesEl.textContent)-1); play(sndExplode); }
        // hit enemy
        enemies.forEach(e=>{
          if(e.dead) return;
          if(Math.abs(e.x - b.x) < e.w/2 && Math.abs(e.y - b.y) < e.h/2){ e.dead = true; b.dead = true; play(sndExplode); }
        });
      });

      // enemy bullets
      enemyBullets.forEach(b=>{
        // 速度降低50%
        if(b.dir==='up') b.y -= 3; else if(b.dir==='down') b.y += 3; else if(b.dir==='left') b.x -= 3; else b.x += 3;
        const gx = Math.floor(b.x/tile), gy = Math.floor(b.y/tile);
        const k = `${gx}|${gy}`;
        // 敌弹不可穿透砖墙
        if(brickWalls.has(k) || steelWalls.has(k)){ b.dead = true; }
        if(b.x<0||b.y<0||b.x>canvas.width||b.y>canvas.height){ b.dead = true; }
        // 命中玩家
        if(Math.abs(player.x - b.x) < 16 && Math.abs(player.y - b.y) < 16){ b.dead = true; play(sndExplode); livesEl.textContent = Math.max(0, Number(livesEl.textContent)-1); }
        // 命中基地
        if(gx>=base.x && gx<base.x+base.w && gy>=base.y && gy<base.y+base.h){ b.dead = true; play(sndExplode); livesEl.textContent = Math.max(0, Number(livesEl.textContent)-1); }
      });
      for(let i=enemyBullets.length-1;i>=0;i--){ if(enemyBullets[i].dead) enemyBullets.splice(i,1); }
      for(let i=bullets.length-1;i>=0;i--){ if(bullets[i].dead) bullets.splice(i,1); }

      // enemy contact with player
      enemies.forEach(e=>{
        if(e.dead) return;
        if(Math.abs(e.x - player.x) < 20 && Math.abs(e.y - player.y) < 20){
          play(sndExplode);
          livesEl.textContent = Math.max(0, Number(livesEl.textContent)-1);
        }
      });

      // victory/defeat check
      const aliveEnemies = enemies.filter(e=>!e.dead).length;
      enemiesEl.textContent = String(aliveEnemies);
      if(Number(livesEl.textContent) <= 0){ paused = true; showOverlay('失败', '基地或玩家阵亡，按 R 重新开始'); }
      if(aliveEnemies === 0){ paused = true; showOverlay('胜利', '清除敌军，按 R 继续'); }

      draw();
      requestAnimationFrame(update);
    }

    function shoot(){ bullets.push({ x: player.x, y: player.y, dir: player.dir }); }

    // simple overlay
    function showOverlay(title, tip){
      const div = document.createElement('div');
      div.style.position='fixed'; div.style.inset='0'; div.style.display='grid'; div.style.placeItems='center';
      div.style.background='rgba(0,0,0,0.6)'; div.style.color='#ffd700'; div.style.font='bold 22px sans-serif';
      div.innerHTML = `<div style="padding:20px 28px;border:2px solid #ffd700;border-radius:12px;background:rgba(0,0,0,0.5)"><div style="font-size:28px;margin-bottom:8px">${title}</div><div style="font-size:14px;color:#00ff00">${tip}</div></div>`;
      document.body.appendChild(div);
      document.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='r'){ window.location.href='index.html'; } }, { once: true });
    }

    pauseBtn.addEventListener('click', ()=>{ paused = !paused; });

    tankImg.onload = ()=>{ draw(); requestAnimationFrame(update); };
  })();
  </script>
</body>
</html>
